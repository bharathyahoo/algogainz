// Prisma schema for AlgoGainz

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Auth provider enum
enum AuthProvider {
  EMAIL
  ZERODHA
}

// User model - supports both email/password and Zerodha OAuth
model User {
  id             String       @id @default(uuid())

  // Common fields
  email          String       @unique
  name           String?
  authProvider   AuthProvider @default(EMAIL) @map("auth_provider")
  createdAt      DateTime     @default(now()) @map("created_at")
  updatedAt      DateTime     @updatedAt @map("updated_at")

  // Email/password auth fields
  password       String?      // Hashed password (null for Zerodha-only users)
  emailVerified  Boolean      @default(false) @map("email_verified")

  // Zerodha Kite auth fields (optional for email-only users)
  kiteUserId     String?      @unique @map("kite_user_id")
  accessToken    String?      @map("access_token")
  tokenExpiry    DateTime?    @map("token_expiry")
  apiKey         String?      @map("api_key")
  apiSecret      String?      @map("api_secret")

  // Relations
  watchlist      Watchlist[]
  transactions   Transaction[]
  holdings       Holding[]
  orders         Order[]
  backtests      BacktestResult[]

  @@map("users")
}

// Watchlist model - stocks user is monitoring
model Watchlist {
  id            String   @id @default(uuid())
  userId        String   @map("user_id")
  stockSymbol   String   @map("stock_symbol")
  companyName   String   @map("company_name")
  exchange      String   @default("NSE") // NSE or BSE
  instrumentToken String @map("instrument_token")
  categories    String[] // Array of category names
  sortOrder     Int      @default(0) @map("sort_order") // For drag-and-drop ordering
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, stockSymbol])
  @@index([userId])
  @@map("watchlist")
}

// Transaction model - all buy/sell transactions
model Transaction {
  id                  String   @id @default(uuid())
  userId              String   @map("user_id")
  stockSymbol         String   @map("stock_symbol")
  companyName         String   @map("company_name")
  type                String   // BUY or SELL
  quantity            Int
  pricePerShare       Float    @map("price_per_share")
  grossAmount         Float    @map("gross_amount") // Price × Quantity

  // Charges breakdown
  brokerage           Float    @default(0)
  exchangeCharges     Float    @default(0) @map("exchange_charges")
  gst                 Float    @default(0)
  sebiCharges         Float    @default(0) @map("sebi_charges")
  stampDuty           Float    @default(0) @map("stamp_duty")
  totalCharges        Float    @map("total_charges")
  netAmount           Float    @map("net_amount") // Gross ± Charges

  // Metadata
  source              String   @default("APP_EXECUTED") // APP_EXECUTED or MANUALLY_RECORDED
  orderIdRef          String?  @map("order_id_ref") // Kite order ID if available
  timestamp           DateTime @default(now())
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  // Relations
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([stockSymbol])
  @@index([userId, stockSymbol])
  @@index([timestamp])
  @@map("transactions")
}

// Order model - tracks orders placed through Kite API
model Order {
  id                  String   @id @default(uuid())
  userId              String   @map("user_id")
  stockSymbol         String   @map("stock_symbol")
  companyName         String   @map("company_name")
  exchange            String   @default("NSE") // NSE or BSE
  instrumentToken     String   @map("instrument_token")

  // Order details
  orderType           String   @map("order_type") // MARKET or LIMIT
  transactionType     String   @map("transaction_type") // BUY or SELL
  quantity            Int
  price               Float?   // Limit price (null for market orders)

  // Kite order details
  kiteOrderId         String?  @unique @map("kite_order_id")
  orderStatus         String   @default("PENDING") @map("order_status") // PENDING, COMPLETE, REJECTED, CANCELLED
  averagePrice        Float?   @map("average_price")
  filledQuantity      Int      @default(0) @map("filled_quantity")

  // Order metadata
  placedAt            DateTime @default(now()) @map("placed_at")
  updatedAt           DateTime @updatedAt @map("updated_at")
  statusMessage       String?  @map("status_message")

  // Relations
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([kiteOrderId])
  @@index([orderStatus])
  @@map("orders")
}

// Holdings model - current positions (calculated from transactions)
model Holding {
  id                  String   @id @default(uuid())
  userId              String   @map("user_id")
  stockSymbol         String   @map("stock_symbol")
  companyName         String   @map("company_name")
  quantity            Int      // Total quantity held
  avgBuyPrice         Float    @map("avg_buy_price")
  totalInvested       Float    @map("total_invested")

  // Real-time data (updated via WebSocket)
  currentPrice        Float?   @map("current_price")
  currentValue        Float?   @map("current_value")
  unrealizedPnL       Float?   @map("unrealized_pnl")
  unrealizedPnLPct    Float?   @map("unrealized_pnl_pct")
  dayChange           Float?   @map("day_change")
  dayChangePct        Float?   @map("day_change_pct")

  // Metadata
  lastUpdated         DateTime @default(now()) @map("last_updated")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  // Relations
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  exitStrategy        ExitStrategy?

  @@unique([userId, stockSymbol])
  @@index([userId])
  @@map("holdings")
}

// Exit Strategy model - profit targets and stop loss
model ExitStrategy {
  id                  String   @id @default(uuid())
  holdingId           String   @unique @map("holding_id")

  // Exit parameters
  profitTargetPct     Float?   @map("profit_target_pct") // e.g., 10.0 for 10%
  profitTargetPrice   Float?   @map("profit_target_price") // Calculated target price
  stopLossPct         Float?   @map("stop_loss_pct") // e.g., 3.0 for 3%
  stopLossPrice       Float?   @map("stop_loss_price") // Calculated stop loss price

  // Alert settings
  alertEnabled        Boolean  @default(true) @map("alert_enabled")
  profitAlertTriggered Boolean @default(false) @map("profit_alert_triggered")
  stopLossAlertTriggered Boolean @default(false) @map("stop_loss_alert_triggered")

  // Metadata
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  // Relations
  holding             Holding  @relation(fields: [holdingId], references: [id], onDelete: Cascade)

  @@map("exit_strategies")
}

// Category model - user-defined watchlist categories (optional, can also use string array)
model Category {
  id          String   @id @default(uuid())
  name        String
  color       String?  // Hex color code for UI
  createdAt   DateTime @default(now()) @map("created_at")

  @@map("categories")
}

// Backtest Result model - stores historical strategy backtesting results
model BacktestResult {
  id                  String   @id @default(uuid())
  userId              String   @map("user_id")

  // Strategy configuration
  strategyName        String   @map("strategy_name")
  stockSymbol         String   @map("stock_symbol")
  companyName         String   @map("company_name")
  startDate           DateTime @map("start_date")
  endDate             DateTime @map("end_date")
  initialCapital      Float    @default(100000) @map("initial_capital") // Starting capital for backtest

  // Entry conditions (stored as JSON)
  entryConditions     Json     @map("entry_conditions")
  // Example: [{ indicator: 'RSI', operator: '<', value: 30 }, { indicator: 'MACD', operator: 'crossover', combinator: 'AND' }]

  // Exit conditions (stored as JSON)
  exitConditions      Json     @map("exit_conditions")
  // Example: [{ type: 'profit_target', value: 10 }, { type: 'stop_loss', value: 3 }]

  // Performance metrics
  totalTrades         Int      @default(0) @map("total_trades")
  winningTrades       Int      @default(0) @map("winning_trades")
  losingTrades        Int      @default(0) @map("losing_trades")
  winRate             Float    @default(0) @map("win_rate") // Percentage

  totalReturn         Float    @default(0) @map("total_return") // Final capital - initial capital
  totalReturnPct      Float    @default(0) @map("total_return_pct") // Percentage
  finalCapital        Float    @default(0) @map("final_capital")

  avgProfitPerTrade   Float    @default(0) @map("avg_profit_per_trade")
  avgLossPerTrade     Float    @default(0) @map("avg_loss_per_trade")
  profitFactor        Float    @default(0) @map("profit_factor") // Gross profit / Gross loss

  largestWin          Float    @default(0) @map("largest_win")
  largestLoss         Float    @default(0) @map("largest_loss")

  maxDrawdown         Float    @default(0) @map("max_drawdown") // Maximum drawdown percentage
  maxDrawdownAmount   Float    @default(0) @map("max_drawdown_amount")

  sharpeRatio         Float?   @map("sharpe_ratio") // Risk-adjusted return
  avgTradeDuration    Float?   @map("avg_trade_duration") // Average holding period in days

  // Trade history (stored as JSON array)
  tradeHistory        Json     @map("trade_history")
  // Example: [{ entryDate, exitDate, entryPrice, exitPrice, quantity, pnl, pnlPct, type: 'WIN'/'LOSS' }]

  // Equity curve data (stored as JSON array)
  equityCurve         Json     @map("equity_curve")
  // Example: [{ date, portfolioValue, cash, position }]

  // Metadata
  status              String   @default("COMPLETED") // RUNNING, COMPLETED, FAILED
  errorMessage        String?  @map("error_message")
  executionTime       Int?     @map("execution_time") // Time taken to run backtest (milliseconds)
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  // Relations
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([stockSymbol])
  @@index([userId, createdAt])
  @@map("backtest_results")
}
